# 数据库的隔离级别和各个隔离级别下解决的问题

隔离级别是用于规定每个事务中做的修改，哪些级别在事务之间是可见的，哪些是不可见的。较低的隔离可以有更高的并发，系统开销更低。



- READ UNCOMMITTED（未提交读RU）：允许脏读，可能读取到其他会话中未提交的事务
  - 内容：未提交读级别，事务中的修改，即使没有提交，对其他事务也可见。事务可以读取未提交的数据，称为脏读。
  - 分析：本级别会导致很多问题，但性能上不会比其他级别好，优点少，一般很少使用。
- READ COMMITTED（已提交读RC）：只能读取到已提交的数据。Oracle等数据库默认级别。
  - 内容：大多数据库默认级别READ COMMITED(MySQL不是)。READ COMMITTED满足隔离性定义，一个事务开始的时候，只能看见已经提交的事务的修改。
  - 分析：（1）提交读级别，事务从开始到提交之前，对数据做的修改，对于其他事务是不可见的。也可以叫不可重复读(non-repeatable read)，两次执行同样的查询，可能会得到不一样的结果。（2）RC级别，数据读取不加锁，但是数据写入、删除、修改需要加锁。
- REPEATABLE READ（可重复读RR）：同一个事务中的查询，都与事务开始前的查询保持一致。消除了不可重复读问题，但是存在幻读问题。
  - 内容：REPEATABLE READ保证在同一个事务中多次读取同样的记录结果保持一致，解决了脏读问题。
  - 分析：（1）可重复读仍无法解决幻读问题(Phantom Read)：幻读，指当某个事务在读取范围内的记录中，另外一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围记录，会有多出的幻行(Phantom Row)。（2）InnDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决幻行问题。（3）为MySQL默认的事务隔离级别。
- SERIALIZABLE（可串行读S）：完全串行化的读，解决幻读问题，但是每次读都要加表级别锁，读写阻塞。
  - SERIALIZABLE可串行化，最高隔离级别。通过强制事务串行执行，避免幻读问题。
  - 分析：（1）SERIALIZABLE会在读取的每一行数据都加锁，可能导致大量的超时和锁争用问题。（2）只有非常需要数据一致性和可以接受没有并发才能用这个级别。